<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Swoole4 文档</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="description" content="由Swoole官方提供的Swoole4系列全量新文档">
    <meta name="keywords" content="php,协程,swoole,swoole4,wiki,swoole文档,swoole手册,swoole4文档,swoole扩展">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="css/Word2Chm.css" type="text/css" />
   <link rel="stylesheet" href="css/default.css" type="text/css" />
             <link rel="stylesheet" href="css/noframe.css" type="text/css" />
      <link rel="stylesheet" href="css/bootstrap.css" type="text/css" />
</head>
<body>
<h1>Coroutine\Socket</h1>
<p><code>Swoole\Coroutine\Socket</code>模块相比<a href="/server/co_init">协程风格服务端</a>和<a href="/coroutine_client/init">协程客户端</a>相关模块<code>Socket</code>可以实现更细粒度的一些<code>IO</code>操作。
!&gt; 可使用<code>Co\Socket</code>短命名简化类名。此模块比较底层，使用者最好有Socket编程经验。
<a name="完整示例"></a></p>
<h2>完整示例</h2>
<pre><code class="language-php">use Swoole\Coroutine;
use function Swoole\Coroutine\run;
run(function () {
    $socket = new Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
    $retval = $socket-&gt;connect('127.0.0.1', 9601);
    while ($retval)
    {
        $n = $socket-&gt;send('hello');
        var_dump($n);
        $data = $socket-&gt;recv();
        var_dump($data);
        //发生错误或对端关闭连接，本端也需要关闭
        if ($data === '' || $data === false) {
            echo "errCode: {$socket-&gt;errCode}\n";
            $socket-&gt;close();
            break;
        }
        Coroutine::sleep(1.0);
    }
    var_dump($retval, $socket-&gt;errCode, $socket-&gt;errMsg);
});</code></pre>
<p><a name="协程调度"></a></p>
<h2>协程调度</h2>
<p><code>Coroutine\Socket</code>模块提供的<code>IO</code>操作接口均为同步编程风格，底层自动使用<a href="/coroutine?id=协程调度">协程调度</a>器实现<a href="/learn?id=同步io异步io">异步IO</a>。
<a name="错误码"></a></p>
<h2>错误码</h2>
<p>在执行<code>socket</code>相关系统调用时，可能返回-1错误，底层会设置<code>Coroutine\Socket-&gt;errCode</code>属性为系统错误编号<code>errno</code>，请参考响应的<code>man</code>文档。如<code>$socket-&gt;accept()</code>返回错误时，<code>errCode</code>含义可以参考<code>man accept</code>中列出的错误码文档。
<a name="属性"></a></p>
<h2>属性</h2>
<p><a name="fd"></a></p>
<h3>fd</h3>
<p><code>socket</code>对应的文件描述符<code>ID</code>
<a name="errCode"></a></p>
<h3>errCode</h3>
<p>错误码
<a name="方法"></a></p>
<h2>方法</h2>
<p><a name="__construct"></a></p>
<h3>__construct()</h3>
<p>构造方法。构造<code>Coroutine\Socket</code>对象。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket::__construct(int $domain, int $type, int $protocol);</code></pre>
<p>!&gt; 详情可参见<code>man socket</code>文档。</p>
<ul>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $domain</code></strong>
<ul>
<li><strong>功能</strong>：协议域【可使用<code>AF_INET</code>、<code>AF_INET6</code>、<code>AF_UNIX</code>】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>int $type</code></strong>
<ul>
<li><strong>功能</strong>：类型【可使用<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>int $protocol</code></strong>
<ul>
<li><strong>功能</strong>：协议【可使用<code>IPPROTO_TCP</code>、<code>IPPROTO_UDP</code>、<code>IPPROTO_STCP</code>、<code>IPPROTO_TIPC</code>，<code>0</code>】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无
!&gt; 构造方法会调用<code>socket</code>系统调用创建一个<code>socket</code>句柄。调用失败时会抛出<code>Swoole\Coroutine\Socket\Exception</code>异常。并设置<code>$socket-&gt;errCode</code>属性。可根据该属性的值得到系统调用失败的原因。
<a name="getOption"></a>
<h3>getOption()</h3>
<p>获取配置。
!&gt; 此方法对应<code>getsockopt</code>系统调用, 详情可参见<code>man getsockopt</code>文档。<br />
此方法和<code>sockets</code>扩展的<code>socket_get_option</code>功能等价, 可以参见<a href="https://www.php.net/manual/zh/function.socket-get-option.php">PHP文档</a>。
!&gt; Swoole版本 &gt;= v4.3.2</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;getOption(int $level, int $optname): mixed</code></pre></li>
</ul></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $level</code></strong>
<ul>
<li><strong>功能</strong>：指定选项所在的协议级别</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无
!&gt; 例如，要在套接字级别检索选项，将使用<code>SOL_SOCKET</code>的 <code>level</code> 参数。<br />
可以通过指定该级别的协议编号来使用其他级别，例如<code>TCP</code>。可以使用<a href="https://www.php.net/manual/zh/function.getprotobyname.php">getprotobyname</a>函数找到协议号。</li>
</ul></li>
<li><strong><code>int $optname</code></strong>
<ul>
<li><strong>功能</strong>：可用的套接字选项与<a href="https://www.php.net/manual/zh/function.socket-get-option.php">socket_get_option()</a>函数的套接字选项相同</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无
<a name="setOption"></a>
<h3>setOption()</h3>
<p>设置配置。
!&gt; 此方法对应<code>setsockopt</code>系统调用, 详情可参见<code>man setsockopt</code>文档。此方法和<code>sockets</code>扩展的<code>socket_set_option</code>功能等价, 可以参见<a href="https://www.php.net/manual/zh/function.socket-set-option.php">PHP文档</a>
!&gt; Swoole版本 &gt;= v4.3.2</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;setOption(int $level, int $optname, mixed $optval): bool</code></pre></li>
</ul></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $level</code></strong>
<ul>
<li><strong>功能</strong>：指定选项所在的协议级别</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无
!&gt; 例如，要在套接字级别检索选项，将使用<code>SOL_SOCKET</code>的 <code>level</code> 参数。<br />
可以通过指定该级别的协议编号来使用其他级别，例如<code>TCP</code>。可以使用<a href="https://www.php.net/manual/zh/function.getprotobyname.php">getprotobyname</a>函数找到协议号。</li>
</ul></li>
<li><strong><code>int $optname</code></strong>
<ul>
<li><strong>功能</strong>：可用的套接字选项与<a href="https://www.php.net/manual/zh/function.socket-get-option.php">socket_get_option()</a>函数的套接字选项相同</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>int $optval</code></strong>
<ul>
<li><strong>功能</strong>：选项的值 【可以是<code>int</code>、<code>bool</code>、<code>string</code>、<code>array</code>。根据<code>level</code>和<code>optname</code>决定。】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无
<a name="setProtocol"></a>
<h3>setProtocol()</h3>
<p>使<code>socket</code>获得协议处理能力，可以配置是否开启<code>SSL</code>加密传输和解决 <a href="/learn?id=tcp数据包边界问题">TCP数据包边界问题</a> 等
!&gt; Swoole版本 &gt;= v4.3.2</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;setProtocol(array $settings): bool</code></pre></li>
</ul></li>
</ul></li>
<li>
<table>
<thead>
<tr>
<th><strong>$settings 支持的参数</strong>
参数</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>open_ssl</td>
<td>bool</td>
</tr>
<tr>
<td>ssl_cert_file</td>
<td>string</td>
</tr>
<tr>
<td>ssl_key_file</td>
<td>string</td>
</tr>
<tr>
<td>open_eof_check</td>
<td>bool</td>
</tr>
<tr>
<td>open_eof_split</td>
<td>bool</td>
</tr>
<tr>
<td>open_mqtt_protocol</td>
<td>bool</td>
</tr>
<tr>
<td>open_fastcgi_protocol</td>
<td>bool</td>
</tr>
<tr>
<td>open_length_check</td>
<td>bool</td>
</tr>
<tr>
<td>package_eof</td>
<td>string</td>
</tr>
<tr>
<td>package_length_type</td>
<td>string</td>
</tr>
<tr>
<td>package_length_offset</td>
<td>int</td>
</tr>
<tr>
<td>package_body_offset</td>
<td>int</td>
</tr>
<tr>
<td>package_length_func</td>
<td>callable</td>
</tr>
<tr>
<td>package_max_length</td>
<td>int</td>
</tr>
</tbody>
</table>
<p>!&gt; 上述所有参数的意义和<a href="/server/setting?id=open_eof_check">Server-&gt;set()</a>完全一致，在此不再赘述。</p>
</li>
<li><strong>示例</strong>
<pre><code class="language-php">$socket-&gt;setProtocol([
'open_length_check'     =&gt; true,
'package_max_length'    =&gt; 1024 * 1024,
'package_length_type'   =&gt; 'N',
'package_length_offset' =&gt; 0,
'package_body_offset'   =&gt; 4,
]);</code></pre>
<p><a name="bind"></a></p>
<h3>bind()</h3>
<p>绑定地址和端口。
!&gt; 此方法没有<code>IO</code>操作，不会引起协程切换</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;bind(string $address, int $port = 0): bool</code></pre></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>string $address</code></strong>
<ul>
<li><strong>功能</strong>：绑定的地址【如<code>0.0.0.0</code>、<code>127.0.0.1</code>】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>int $port</code></strong>
<ul>
<li><strong>功能</strong>：：绑定的端口【默认为<code>0</code>，系统会随机绑定一个可用端口，可使用<a href="/coroutine_client/socket?id=getsockname">getsockname</a>方法得到系统分配的<code>port</code>】</li>
<li><strong>默认值</strong>：<code>0</code></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>绑定成功返回<code>true</code></li>
<li>绑定失败返回<code>false</code>，请检查<code>errCode</code>属性获取失败原因
<a name="listen"></a>
<h3>listen()</h3>
<p>监听<code>Socket</code>。
!&gt; 此方法没有<code>IO</code>操作，不会引起协程切换</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;listen(int $backlog = 0): bool</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $backlog</code></strong>
<ul>
<li><strong>功能</strong>：监听队列的长度【默认为<code>0</code>，系统底层使用<code>epoll</code>实现了异步<code>IO</code>，不存在阻塞，因此<code>backlog</code>的重要程度并不高】</li>
<li><strong>默认值</strong>：<code>0</code></li>
<li><strong>其它值</strong>：无
!&gt; 如果应用中存在阻塞或耗时逻辑，<code>accept</code>接受连接不及时，新创建的连接就会堆积在<code>backlog</code>监听队列中，如超出<code>backlog</code>长度，服务就会拒绝新的连接进入</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>绑定成功返回<code>true</code></li>
<li>绑定失败返回<code>false</code>，请检查<code>errCode</code>属性获取失败原因</li>
</ul></li>
<li><strong>内核参数</strong>
<code>backlog</code>的最大值受限于内核参数<code>net.core.somaxconn</code>, 而<code>Linux</code>中可以工具<code>sysctl</code>来动态调整所有的<code>kernel</code>参数。动态调整是内核参数值修改后即时生效。但是这个生效仅限于<code>OS</code>层面，必须重启应用才能真正生效, 命令<code>sysctl -a</code>会显示所有的内核参数及值。
<pre><code class="language-shell">sysctl -w net.core.somaxconn=2048</code></pre>
<p>以上命令将内核参数<code>net.core.somaxconn</code>的值改成了<code>2048</code>。这样的改动虽然可以立即生效，但是重启机器后会恢复默认值。为了永久保留改动，需要修改<code>/etc/sysctl.conf</code>，增加<code>net.core.somaxconn=2048</code>然后执行命令<code>sysctl -p</code>生效。
<a name="accept"></a></p>
<h3>accept()</h3>
<p>接受客户端发起的连接。
调用此方法会立即挂起当前协程，并加入<a href="/learn?id=什么是eventloop">EventLoop</a>监听可读事件，当<code>Socket</code>可读有到来的连接时自动唤醒该协程，并返回对应客户端连接的<code>Socket</code>对象。
!&gt; 该方法必须在使用<code>listen</code>方法后使用，适用于<code>Server</code>端。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;accept(float $timeout = 0): Coroutine\Socket|false;</code></pre></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时【设置超时参数后，底层会设置定时器，在规定的时间没有客户端连接到来，<code>accept</code>方法将返回<code>false</code>】</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>超时或<code>accept</code>系统调用报错时返回<code>false</code>，可使用<code>errCode</code>属性获取错误码，其中超时错误码为<code>ETIMEDOUT</code></li>
<li>成功返回客户端连接的<code>socket</code>，类型同样为<code>Swoole\Coroutine\Socket</code>对象。可对其执行<code>send</code>、<code>recv</code>、<code>close</code>等操作</li>
</ul></li>
<li><strong>示例</strong>
<pre><code class="language-php">use Swoole\Coroutine;
use function Swoole\Coroutine\run;
run(function () {
$socket = new Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
$socket-&gt;bind('127.0.0.1', 9601);
$socket-&gt;listen(128);
while(true) {
    echo "Accept: \n";
    $client = $socket-&gt;accept();
    if ($client === false) {
        var_dump($socket-&gt;errCode);
    } else {
        var_dump($client);
    }
}
});</code></pre>
<p><a name="connect"></a></p>
<h3>connect()</h3>
<p>连接到目标服务器。
调用此方法会发起异步的<code>connect</code>系统调用，并挂起当前协程，底层会监听可写，当连接完成或失败后，恢复该协程。
该方法适用于<code>Client</code>端，支持<code>IPv4</code>、<code>IPv6</code>、<a href="/learn?id=什么是IPC">unixSocket</a>。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;connect(string $host, int $port = 0, float $timeout = 0): bool</code></pre></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>string $host</code></strong>
<ul>
<li><strong>功能</strong>：目标服务器的地址【如<code>127.0.0.1</code>、<code>192.168.1.100</code>、<code>/tmp/php-fpm.sock</code>、<code>www.baidu.com</code>等，可以传入<code>IP</code>地址、<code>Unix Socket</code>路径或域名。若为域名，底层会自动进行异步的<code>DNS</code>解析，不会引起阻塞】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>int $port</code></strong>
<ul>
<li><strong>功能</strong>：目标服务器端口【<code>Socket</code>的<code>domain</code>为<code>AF_INET</code>、<code>AF_INET6</code>时必须设置端口】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间【底层会设置定时器，在规定的时间内未能建立连接，<code>connect</code>将返回<code>false</code>】</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>超时或<code>connect</code>系统调用报错时返回<code>false</code>，可使用<code>errCode</code>属性获取错误码，其中超时错误码为<code>ETIMEDOUT</code></li>
<li>成功返回<code>true</code>
<a name="checkLiveness"></a>
<h3>checkLiveness()</h3>
<p>通过系统调用检查连接是否存活 (在异常断开时无效, 仅能侦测到对端正常close下的连接断开)
!&gt; Swoole版本 &gt;= <code>v4.5.0</code> 可用</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;checkLiveness(): bool</code></pre></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>连接存活时返回<code>true</code>, 否则返回<code>false</code>
<a name="send"></a>
<h3>send()</h3>
<p>向对端发送数据。
!&gt; <code>send</code>方法会立即执行<code>send</code>系统调用发送数据，当<code>send</code>系统调用返回错误<code>EAGAIN</code>时，底层将自动监听可写事件，并挂起当前协程，等待可写事件触发时，重新执行<code>send</code>系统调用发送数据，并唤醒该协程。<br />
!&gt; 如果<code>send</code>过快，<code>recv</code>过慢最终会导致操作系统缓冲区写满，当前协程挂起在send方法，可以适当调大缓冲区，<a href="https://stackoverflow.com/questions/21856517/whats-the-practical-limit-on-the-size-of-single-packet-transmitted-over-domain">/proc/sys/net/core/wmem_max和SO_SNDBUF</a></p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;send(string $data, float $timeout = 0): int|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>string $data</code></strong>
<ul>
<li><strong>功能</strong>：要发送的数据内容【可以为文本或二进制数据】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>发送成功返回写入的字节数，<strong>请注意实际写入的数据可能小于<code>$data</code>参数的长度</strong>，应用层代码需要对比返回值与<code>strlen($data)</code>是否相等来判断是否发送完成</li>
<li>发送失败返回<code>false</code>，并设置<code>errCode</code>属性
<a name="sendAll"></a>
<h3>sendAll()</h3>
<p>向对端发送数据。与<code>send</code>方法不同的是, <code>sendAll</code>会尽可能完整地发送数据, 直到成功发送全部数据或遇到错误中止。
!&gt; <code>sendAll</code>方法会立即执行多次<code>send</code>系统调用发送数据，当<code>send</code>系统调用返回错误<code>EAGAIN</code>时，底层将自动监听可写事件，并挂起当前协程，等待可写事件触发时，重新执行<code>send</code>系统调用发送数据, 直到数据发送完成或遇到错误, 唤醒对应协程。<br />
!&gt; Swoole版本 &gt;= v4.3.0</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;sendAll(string $data, float $timeout = 0) : int | false;</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>string $data</code></strong>
<ul>
<li><strong>功能</strong>：要发送的数据内容【可以为文本或二进制数据】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li><code>sendAll</code>会保证数据全部发送成功，但是<code>sendAll</code>期间对端有可能将连接断开，此时可能发送成功了部分数据，返回值会返回这个成功数据的长度，应用层代码需要对比返回值与<code>strlen($data)</code>是否相等来判断是否发送完成，根据业务需求是否需要续传。</li>
<li>发送失败返回<code>false</code>，并设置<code>errCode</code>属性
<a name="peek"></a>
<h3>peek()</h3>
<p>窥视读缓冲区中的数据, 相当于系统调用中的<code>recv(length, MSG_PEEK)</code>。
!&gt; <code>peek</code>是立即完成的, 不会挂起协程, 但有一次系统调用开销</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;peek(int $length = 65535): string|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $length</code></strong>
<ul>
<li><strong>功能</strong>：指定用于拷贝窥视到的数据的内存大小 (注意：这里会分配内存, 过大的长度可能会导致内存耗尽)</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>窥视成功返回数据</li>
<li>窥视失败返回<code>false</code>，并设置<code>errCode</code>属性
<a name="recv"></a>
<h3>recv()</h3>
<p>接收数据。
!&gt; <code>recv</code>方法会立即挂起当前协程并监听可读事件，等待对端发送数据后，可读事件触发时，执行<code>recv</code>系统调用获取<code>socket</code>缓存区中的数据，并唤醒该协程。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;recv(int $length = 65535, float $timeout = 0): string|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $length</code></strong>
<ul>
<li><strong>功能</strong>：指定用于接收数据的内存大小 (注意：这里会分配内存, 过大的长度可能会导致内存耗尽)</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>接收成功返回实际数据</li>
<li>接收失败返回<code>false</code>，并设置<code>errCode</code>属性</li>
<li>接收超时，错误码为<code>ETIMEDOUT</code>
!&gt; 返回值不一定等于预期长度, 需要自行检查该次调用接收数据的长度, 如需要保证单次调用获取到指定长度的数据, 请使用<code>recvAll</code>方法或自行循环获取<br />
TCP数据包边界问题请参考<code>setProtocol()</code>方法，或者用<code>sendto()</code>;
<a name="recvAll"></a>
<h3>recvAll()</h3>
<p>接收数据。与<code>recv</code>不同的是, <code>recvAll</code>会尽可能完整地接收响应长度的数据, 直到接收完成或遇到错误失败。
!&gt; <code>recvAll</code>方法会立即挂起当前协程并监听可读事件，等待对端发送数据后，可读事件触发时，执行<code>recv</code>系统调用获取<code>socket</code>缓存区中的数据, 重复该行为直到接收到指定长度的数据或遇到错误终止，并唤醒该协程。
!&gt; Swoole版本 &gt;= v4.3.0</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;recvAll(int $length = 65535, float $timeout = 0): string|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>int $length</code></strong>
<ul>
<li><strong>功能</strong>：期望接收到的数据大小 (注意：这里会分配内存, 过大的长度可能会导致内存耗尽)</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>接收成功返回实际数据, 并且返回的字符串长度和参数长度一致</li>
<li>接收失败返回<code>false</code>，并设置<code>errCode</code>属性</li>
<li>接收超时，错误码为<code>ETIMEDOUT</code>
<a name="readVector"></a>
<h3>readVector()</h3>
<p>分段接收数据。
!&gt; <code>readVector</code>方法会立即执行<code>readv</code>系统调用读取数据，当<code>readv</code>系统调用返回错误<code>EAGAIN</code>时，底层将自动监听可读事件，并挂起当前协程，等待可读事件触发时，重新执行<code>readv</code>系统调用读取数据，并唤醒该协程。<br />
!&gt; Swoole版本 &gt;= v4.5.7</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;readVector(array $io_vector, float $timeout = 0): array|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>array $io_vector</code></strong>
<ul>
<li><strong>功能</strong>：期望接收到的分段数据大小</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li>接收成功返回的分段数据</li>
<li>接收失败返回空数组，并设置<code>errCode</code>属性</li>
<li>接收超时，错误码为<code>ETIMEDOUT</code></li>
</ul></li>
<li><strong>示例</strong> 
<pre><code class="language-php">$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
// 如果对端发来了helloworld
$ret = $socket-&gt;readVector([5, 5]);
// 那么，$ret是['hello', 'world']</code></pre>
<p><a name="readVectorAll"></a></p>
<h3>readVectorAll()</h3>
<p>分段接收数据。
!&gt; <code>readVectorAll</code>方法会立即执行多次<code>readv</code>系统调用读取数据，当<code>readv</code>系统调用返回错误<code>EAGAIN</code>时，底层将自动监听可读事件，并挂起当前协程，等待可读事件触发时，重新执行<code>readv</code>系统调用读取数据, 直到数据读取完成或遇到错误, 唤醒对应协程。
!&gt; Swoole版本 &gt;= v4.5.7</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;readVectorAll(array $io_vector, float $timeout = 0): array|false</code></pre></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>array $io_vector</code></strong>
<ul>
<li><strong>功能</strong>：期望接收到的分段数据大小</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li>接收成功返回的分段数据</li>
<li>接收失败返回空数组，并设置<code>errCode</code>属性</li>
<li>接收超时，错误码为<code>ETIMEDOUT</code>
<a name="writeVector"></a>
<h3>writeVector()</h3>
<p>分段发送数据。
!&gt; <code>writeVector</code>方法会立即执行<code>writev</code>系统调用发送数据，当<code>writev</code>系统调用返回错误<code>EAGAIN</code>时，底层将自动监听可写事件，并挂起当前协程，等待可写事件触发时，重新执行<code>writev</code>系统调用发送数据，并唤醒该协程。<br />
!&gt; Swoole版本 &gt;= v4.5.7</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;writeVector(array $io_vector, float $timeout = 0): int|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>array $io_vector</code></strong>
<ul>
<li><strong>功能</strong>：期望发送的分段数据</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li>发送成功返回写入的字节数，<strong>请注意实际写入的数据可能小于<code>$io_vector</code>参数的总长度</strong>，应用层代码需要对比返回值与<code>$io_vector</code>参数的总长度是否相等来判断是否发送完成</li>
<li>发送失败返回<code>false</code>，并设置<code>errCode</code>属性</li>
</ul></li>
<li><strong>示例</strong> 
<pre><code class="language-php">$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
// 此时会按照数组里面的顺序发送给对端，实际上就是发送helloworld
$socket-&gt;writeVector(['hello', 'world']);</code></pre>
<p><a name="writeVectorAll"></a></p>
<h3>writeVectorAll()</h3>
<p>向对端发送数据。与<code>writeVector</code>方法不同的是, <code>writeVectorAll</code>会尽可能完整地发送数据, 直到成功发送全部数据或遇到错误中止。
!&gt; <code>writeVectorAll</code>方法会立即执行多次<code>writev</code>系统调用发送数据，当<code>writev</code>系统调用返回错误<code>EAGAIN</code>时，底层将自动监听可写事件，并挂起当前协程，等待可写事件触发时，重新执行<code>writev</code>系统调用发送数据, 直到数据发送完成或遇到错误, 唤醒对应协程。
!&gt; Swoole版本 &gt;= v4.5.7</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;writeVectorAll(array $io_vector, float $timeout = 0): int|false</code></pre></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>array $io_vector</code></strong>
<ul>
<li><strong>功能</strong>：期望发送的分段数据</li>
<li><strong>值单位</strong>：字节</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li><code>writeVectorAll</code>会保证数据全部发送成功，但是<code>writeVectorAll</code>期间对端有可能将连接断开，此时可能发送成功了部分数据，返回值会返回这个成功数据的长度，应用层代码需要对比返回值与<code>$io_vector</code>参数的总长度是否相等来判断是否发送完成，根据业务需求是否需要续传。</li>
<li>发送失败返回<code>false</code>，并设置<code>errCode</code>属性</li>
</ul></li>
<li><strong>示例</strong> 
<pre><code class="language-php">$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
// 此时会按照数组里面的顺序发送给对端，实际上就是发送helloworld
$socket-&gt;writeVectorAll(['hello', 'world']);</code></pre>
<p><a name="recvPacket"></a></p>
<h3>recvPacket()</h3>
<p>对于已通过<code>setProtocol</code>方法设置协议的Socket对象, 可调用此方法接收一个完整的协议数据包
!&gt; Swoole版本 &gt;= v4.4.0</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;recvPacket(float $timeout = 0): string|false</code></pre></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>接收成功返回一个完整协议数据包</li>
<li>接收失败返回<code>false</code>，并设置<code>errCode</code>属性</li>
<li>接收超时，错误码为<code>ETIMEDOUT</code>
<a name="recvLine"></a>
<h3>recvLine()</h3>
<p>用于解决 <a href="https://www.php.net/manual/en/function.socket-read.php">socket_read</a> 兼容性问题</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;recvLine(int $length = 65535, float $timeout = 0): string|false</code></pre>
<p><a name="recvWithBuffer"></a></p>
<h3>recvWithBuffer()</h3>
<p>用于解决使用 <code>recv(1)</code> 逐字节接收时产生大量系统调用问题</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;recvWithBuffer(int $length = 65535, float $timeout = 0): string|false</code></pre>
<p><a name="recvfrom"></a></p>
<h3>recvfrom()</h3>
<p>接收数据，并设置来源主机的地址和端口。用于<code>SOCK_DGRAM</code>类型的<code>socket</code>。
!&gt; 此方法会引起<a href="/coroutine?id=协程调度">协程调度</a>，底层会立即挂起当前协程，并监听可读事件。可读事件触发，收到数据后执行<code>recvfrom</code>系统调用获取数据包。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;recvfrom(array &amp;$peer, float $timeout = 0): string|false</code></pre></li>
<li><strong>参数</strong></li>
<li><strong><code>array $peer</code></strong>
<ul>
<li><strong>功能</strong>：对端地址和端口，引用类型。【函数成功返回时会设置为数组，包括<code>address</code>和<code>port</code>两个元素】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>float $timeout</code></strong>
<ul>
<li><strong>功能</strong>：设置超时时间【在规定的时间内未返回数据，<code>recvfrom</code>方法会返回<code>false</code>】</li>
<li><strong>值单位</strong>：秒【支持浮点型，如<code>1.5</code>表示<code>1s</code>+<code>500ms</code>】</li>
<li><strong>默认值</strong>：参考<a href="/coroutine_client/init?id=超时规则">客户端超时规则</a></li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong>返回值</strong></li>
<li>成功接收数据，返回数据内容，并设置<code>$peer</code>为数组</li>
<li>失败返回<code>false</code>，并设置<code>errCode</code>属性，不修改<code>$peer</code>的内容</li>
<li><strong>示例</strong>
<pre><code class="language-php">use Swoole\Coroutine;
use function Swoole\Coroutine\run;
run(function () {
$socket = new Coroutine\Socket(AF_INET, SOCK_DGRAM, 0);
$socket-&gt;bind('127.0.0.1', 9601);
while (true) {
$peer = null;
$data = $socket-&gt;recvfrom($peer);
echo "[Server] recvfrom[{$peer['address']}:{$peer['port']}] : $data\n";
$socket-&gt;sendto($peer['address'], $peer['port'], "Swoole: $data");
}
});</code></pre>
<p><a name="sendto"></a></p>
<h3>sendto()</h3>
<p>向指定的地址和端口发送数据。用于<code>SOCK_DGRAM</code>类型的<code>socket</code>。
!&gt; 此方法没有<a href="/coroutine?id=协程调度">协程调度</a>，底层会立即调用<code>sendto</code>向目标主机发送数据。此方法不会监听可写，<code>sendto</code>可能会因为缓存区已满而返会<code>false</code>，需要自行处理，或者使用<code>send</code>方法。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;sendto(string $address, int $port, string $data): int|false</code></pre></li>
</ul></li>
<li><strong>参数</strong> 
<ul>
<li><strong><code>string $address</code></strong>
<ul>
<li><strong>功能</strong>：目标主机的<code>IP</code>地址或<a href="/learn?id=什么是IPC">unixSocket</a>路径【<code>sendto</code>不支持域名，使用<code>AF_INET</code>或<code>AF_INET6</code>时，必须传入合法的<code>IP</code>地址，否则发送会返回失败】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>int $port</code></strong>
<ul>
<li><strong>功能</strong>：目标主机的端口【发送广播时可以为<code>0</code>】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
<li><strong><code>string $data</code></strong>
<ul>
<li><strong>功能</strong>：发送的数据【可以为文本或二进制内容，请注意<code>SOCK_DGRAM</code>发送包的最大长度为<code>64K</code>】</li>
<li><strong>默认值</strong>：无</li>
<li><strong>其它值</strong>：无</li>
</ul></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>发送成功返回发送的字节数</li>
<li>发送失败返回<code>false</code>，并设置<code>errCode</code>属性</li>
</ul></li>
<li><strong>示例</strong> 
<pre><code class="language-php">$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_DGRAM, 0);
$socket-&gt;sendto('127.0.0.1', 9601, 'Hello');</code></pre>
<p><a name="getsockname"></a></p>
<h3>getsockname()</h3>
<p>获取socket的地址和端口信息。
!&gt; 此方法没有<a href="/coroutine?id=协程调度">协程调度</a>开销。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;getsockname(): array|false</code></pre></li>
<li><strong>返回值</strong> 
<ul>
<li>调用成功返回，包含<code>address</code>和<code>port</code>的数组</li>
<li>调用失败返回<code>false</code>，并设置<code>errCode</code>属性
<a name="getpeername"></a>
<h3>getpeername()</h3>
<p>获取<code>socket</code>的对端地址和端口信息，仅用于<code>SOCK_STREAM</code>类型有连接的<code>socket</code>。
?&gt; 此方法没有<a href="/coroutine?id=协程调度">协程调度</a>开销。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;getpeername(): array|false</code></pre></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>调用成功返回，包含<code>address</code>和<code>port</code>的数组</li>
<li>调用失败返回<code>false</code>，并设置<code>errCode</code>属性
<a name="close"></a>
<h3>close()</h3>
<p>关闭<code>Socket</code>。
!&gt; <code>Swoole\Coroutine\Socket</code>对象析构时如果会自动执行<code>close</code>，此方法没有<a href="/coroutine?id=协程调度">协程调度</a>开销。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;close(): bool</code></pre></li>
</ul></li>
<li><strong>返回值</strong> 
<ul>
<li>关闭成功返回<code>true</code></li>
<li>失败返回<code>false</code></li>
</ul></li>
</ul>
<p><a name="isClosed"></a></p>
<h3>isClosed()</h3>
<p><code>Socket</code>是否已关闭。</p>
<pre><code class="language-php">Swoole\Coroutine\Socket-&gt;isClosed(): bool</code></pre>
<p><a name="常量"></a></p>
<h2>常量</h2>
<p>等价于<code>sockets</code>扩展提供的常量, 且不会与<code>sockets</code>扩展产生冲突
!&gt; 在不同系统下的值会有出入, 以下代码仅为示例, 请勿使用其值</p>
<pre><code class="language-php">define ('AF_UNIX', 1);
define ('AF_INET', 2);
/**
 * Only available if compiled with IPv6 support.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('AF_INET6', 10);
define ('SOCK_STREAM', 1);
define ('SOCK_DGRAM', 2);
define ('SOCK_RAW', 3);
define ('SOCK_SEQPACKET', 5);
define ('SOCK_RDM', 4);
define ('MSG_OOB', 1);
define ('MSG_WAITALL', 256);
define ('MSG_CTRUNC', 8);
define ('MSG_TRUNC', 32);
define ('MSG_PEEK', 2);
define ('MSG_DONTROUTE', 4);
/**
 * Not available on Windows platforms.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('MSG_EOR', 128);
/**
 * Not available on Windows platforms.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('MSG_EOF', 512);
define ('MSG_CONFIRM', 2048);
define ('MSG_ERRQUEUE', 8192);
define ('MSG_NOSIGNAL', 16384);
define ('MSG_DONTWAIT', 64);
define ('MSG_MORE', 32768);
define ('MSG_WAITFORONE', 65536);
define ('MSG_CMSG_CLOEXEC', 1073741824);
define ('SO_DEBUG', 1);
define ('SO_REUSEADDR', 2);
/**
 * This constant is only available in PHP 5.4.10 or later on platforms that
 * support the &lt;b&gt;SO_REUSEPORT&lt;/b&gt; socket option: this
 * includes Mac OS X and FreeBSD, but does not include Linux or Windows.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SO_REUSEPORT', 15);
define ('SO_KEEPALIVE', 9);
define ('SO_DONTROUTE', 5);
define ('SO_LINGER', 13);
define ('SO_BROADCAST', 6);
define ('SO_OOBINLINE', 10);
define ('SO_SNDBUF', 7);
define ('SO_RCVBUF', 8);
define ('SO_SNDLOWAT', 19);
define ('SO_RCVLOWAT', 18);
define ('SO_SNDTIMEO', 21);
define ('SO_RCVTIMEO', 20);
define ('SO_TYPE', 3);
define ('SO_ERROR', 4);
define ('SO_BINDTODEVICE', 25);
define ('SOL_SOCKET', 1);
define ('SOMAXCONN', 128);
/**
 * Used to disable Nagle TCP algorithm.
 * Added in PHP 5.2.7.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('TCP_NODELAY', 1);
define ('PHP_NORMAL_READ', 1);
define ('PHP_BINARY_READ', 2);
define ('MCAST_JOIN_GROUP', 42);
define ('MCAST_LEAVE_GROUP', 45);
define ('MCAST_BLOCK_SOURCE', 43);
define ('MCAST_UNBLOCK_SOURCE', 44);
define ('MCAST_JOIN_SOURCE_GROUP', 46);
define ('MCAST_LEAVE_SOURCE_GROUP', 47);
define ('IP_MULTICAST_IF', 32);
define ('IP_MULTICAST_TTL', 33);
define ('IP_MULTICAST_LOOP', 34);
define ('IPV6_MULTICAST_IF', 17);
define ('IPV6_MULTICAST_HOPS', 18);
define ('IPV6_MULTICAST_LOOP', 19);
define ('IPV6_V6ONLY', 27);
/**
 * Operation not permitted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPERM', 1);
/**
 * No such file or directory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOENT', 2);
/**
 * Interrupted system call.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EINTR', 4);
/**
 * I/O error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EIO', 5);
/**
 * No such device or address.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENXIO', 6);
/**
 * Arg list too long.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_E2BIG', 7);
/**
 * Bad file number.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADF', 9);
/**
 * Try again.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EAGAIN', 11);
/**
 * Out of memory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOMEM', 12);
/**
 * Permission denied.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EACCES', 13);
/**
 * Bad address.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EFAULT', 14);
/**
 * Block device required.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTBLK', 15);
/**
 * Device or resource busy.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBUSY', 16);
/**
 * File exists.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EEXIST', 17);
/**
 * Cross-device link.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EXDEV', 18);
/**
 * No such device.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENODEV', 19);
/**
 * Not a directory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTDIR', 20);
/**
 * Is a directory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EISDIR', 21);
/**
 * Invalid argument.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EINVAL', 22);
/**
 * File table overflow.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENFILE', 23);
/**
 * Too many open files.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMFILE', 24);
/**
 * Not a typewriter.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTTY', 25);
/**
 * No space left on device.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSPC', 28);
/**
 * Illegal seek.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESPIPE', 29);
/**
 * Read-only file system.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EROFS', 30);
/**
 * Too many links.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMLINK', 31);
/**
 * Broken pipe.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPIPE', 32);
/**
 * File name too long.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENAMETOOLONG', 36);
/**
 * No record locks available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOLCK', 37);
/**
 * Function not implemented.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSYS', 38);
/**
 * Directory not empty.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTEMPTY', 39);
/**
 * Too many symbolic links encountered.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ELOOP', 40);
/**
 * Operation would block.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EWOULDBLOCK', 11);
/**
 * No message of desired type.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOMSG', 42);
/**
 * Identifier removed.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EIDRM', 43);
/**
 * Channel number out of range.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECHRNG', 44);
/**
 * Level 2 not synchronized.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL2NSYNC', 45);
/**
 * Level 3 halted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL3HLT', 46);
/**
 * Level 3 reset.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL3RST', 47);
/**
 * Link number out of range.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ELNRNG', 48);
/**
 * Protocol driver not attached.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EUNATCH', 49);
/**
 * No CSI structure available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOCSI', 50);
/**
 * Level 2 halted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL2HLT', 51);
/**
 * Invalid exchange.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADE', 52);
/**
 * Invalid request descriptor.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADR', 53);
/**
 * Exchange full.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EXFULL', 54);
/**
 * No anode.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOANO', 55);
/**
 * Invalid request code.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADRQC', 56);
/**
 * Invalid slot.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADSLT', 57);
/**
 * Device not a stream.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSTR', 60);
/**
 * No data available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENODATA', 61);
/**
 * Timer expired.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ETIME', 62);
/**
 * Out of streams resources.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSR', 63);
/**
 * Machine is not on the network.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENONET', 64);
/**
 * Object is remote.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EREMOTE', 66);
/**
 * Link has been severed.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOLINK', 67);
/**
 * Advertise error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EADV', 68);
/**
 * Srmount error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESRMNT', 69);
/**
 * Communication error on send.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECOMM', 70);
/**
 * Protocol error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPROTO', 71);
/**
 * Multihop attempted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMULTIHOP', 72);
/**
 * Not a data message.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADMSG', 74);
/**
 * Name not unique on network.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTUNIQ', 76);
/**
 * File descriptor in bad state.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADFD', 77);
/**
 * Remote address changed.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EREMCHG', 78);
/**
 * Interrupted system call should be restarted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ERESTART', 85);
/**
 * Streams pipe error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESTRPIPE', 86);
/**
 * Too many users.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EUSERS', 87);
/**
 * Socket operation on non-socket.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTSOCK', 88);
/**
 * Destination address required.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EDESTADDRREQ', 89);
/**
 * Message too long.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMSGSIZE', 90);
/**
 * Protocol wrong type for socket.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPROTOTYPE', 91);
define ('SOCKET_ENOPROTOOPT', 92);
/**
 * Protocol not supported.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPROTONOSUPPORT', 93);
/**
 * Socket type not supported.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESOCKTNOSUPPORT', 94);
/**
 * Operation not supported on transport endpoint.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EOPNOTSUPP', 95);
/**
 * Protocol family not supported.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPFNOSUPPORT', 96);
/**
 * Address family not supported by protocol.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EAFNOSUPPORT', 97);
define ('SOCKET_EADDRINUSE', 98);
/**
 * Cannot assign requested address.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EADDRNOTAVAIL', 99);
/**
 * Network is down.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENETDOWN', 100);
/**
 * Network is unreachable.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENETUNREACH', 101);
/**
 * Network dropped connection because of reset.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENETRESET', 102);
/**
 * Software caused connection abort.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECONNABORTED', 103);
/**
 * Connection reset by peer.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECONNRESET', 104);
/**
 * No buffer space available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOBUFS', 105);
/**
 * Transport endpoint is already connected.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EISCONN', 106);
/**
 * Transport endpoint is not connected.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTCONN', 107);
/**
 * Cannot send after transport endpoint shutdown.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESHUTDOWN', 108);
/**
 * Too many references: cannot splice.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ETOOMANYREFS', 109);
/**
 * Connection timed out.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ETIMEDOUT', 110);
/**
 * Connection refused.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECONNREFUSED', 111);
/**
 * Host is down.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EHOSTDOWN', 112);
/**
 * No route to host.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EHOSTUNREACH', 113);
/**
 * Operation already in progress.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EALREADY', 114);
/**
 * Operation now in progress.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EINPROGRESS', 115);
/**
 * Is a named type file.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EISNAM', 120);
/**
 * Remote I/O error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EREMOTEIO', 121);
/**
 * Quota exceeded.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EDQUOT', 122);
/**
 * No medium found.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOMEDIUM', 123);
/**
 * Wrong medium type.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMEDIUMTYPE', 124);
define ('IPPROTO_IP', 0);
define ('IPPROTO_IPV6', 41);
define ('SOL_TCP', 6);
define ('SOL_UDP', 17);
define ('IPV6_UNICAST_HOPS', 16);
define ('IPV6_RECVPKTINFO', 49);
define ('IPV6_PKTINFO', 50);
define ('IPV6_RECVHOPLIMIT', 51);
define ('IPV6_HOPLIMIT', 52);
define ('IPV6_RECVTCLASS', 66);
define ('IPV6_TCLASS', 67);
define ('SCM_RIGHTS', 1);
define ('SCM_CREDENTIALS', 2);
define ('SO_PASSCRED', 16);</code></pre>
</body>
</html>